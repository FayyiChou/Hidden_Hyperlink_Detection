<!DOCTYPE html>
<html lang="zh-cn">
 <head> 
  <meta charset="utf-8" /> 
  <meta name="viewport" content="width=device-width, initial-scale=1" /> 
  <title>老司机教你下载tumblr上视频和图片的正确姿势 - 玄魂 - 博客园</title> 
  <link type="text/css" rel="stylesheet" href="/bundles/blog-common.css?v=m_FXmwz3wxZoecUwNEK23PAzc-j9vbX_C6MblJ5ouMc1" /> 
  <link id="MainCss" type="text/css" rel="stylesheet" href="/skins/BlueFresh/bundle-BlueFresh.css?v=b3yN5lKt4bOBKbsD14DAsAqpqqfyM4Ejm9hmWmfDgXg1" /> 
  <link type="text/css" rel="stylesheet" href="/blog/customcss/46115.css?v=8swWJ55%2bai5f8b6nfqrKMLsMzCs%3d" /> 
  <link id="mobile-style" media="only screen and (max-width: 768px)" type="text/css" rel="stylesheet" href="/skins/BlueFresh/bundle-BlueFresh-mobile.css?v=r_DbNAtoCoEEu7YPF-VUEZIOMZhZGuEmEpMmfK09q341" /> 
  <link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/xuanhun/rss" /> 
  <link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/xuanhun/rsd.xml" /> 
  <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/xuanhun/wlwmanifest.xml" /> 
  <script src="//common.cnblogs.com/script/jquery.js" type="text/javascript"></script> 
  <script type="text/javascript">var currentBlogApp = 'xuanhun', cb_enable_mathjax=true;var isLogined=false;</script> 
  <script src="/bundles/blog-common.js?v=HjE8xh24aOra0V_HP38wxIHV3lfHC5polwLAK3mmjdg1" type="text/javascript"></script> 
 </head> 
 <body> 
  <a name="top"></a> 
  <!--done--> 
  <div id="home"> 
   <div id="header"> 
    <div id="blogTitle"> 
     <a id="lnkBlogLogo" href="http://www.cnblogs.com/xuanhun/"><img id="blogLogo" src="/Skins/custom/images/logo.gif" alt="返回主页" /></a> 
     <!--done--> 
     <h1><a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/xuanhun/">玄魂工作室</a></h1> 
     <h2>探讨实践与真理的距离</h2> 
    </div>
    <!--end: blogTitle 博客的标题和副标题 --> 
    <div id="navigator"> 
     <ul id="navList"> 
      <li><a id="blog_nav_sitehome" class="menu" href="http://www.cnblogs.com/">博客园</a></li> 
      <li><a id="blog_nav_myhome" class="menu" href="http://www.cnblogs.com/xuanhun/">首页</a></li> 
      <li><a id="blog_nav_newpost" class="menu" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a></li> 
      <li><a id="blog_nav_contact" class="menu" rel="nofollow" href="https://msg.cnblogs.com/send/%E7%8E%84%E9%AD%82">联系</a></li> 
      <li><a id="blog_nav_rss" class="menu" href="http://www.cnblogs.com/xuanhun/rss">订阅</a> 
       <!--<a id="blog_nav_rss_image" class="aHeaderXML" href="http://www.cnblogs.com/xuanhun/rss"><img src="//www.cnblogs.com/images/xml.gif" alt="订阅" /></a>--></li> 
      <li><a id="blog_nav_admin" class="menu" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li> 
     </ul> 
     <div class="blogStats"> 
      <div id="blog_stats"> 
       <span id="stats_post_count">随笔 - 280&nbsp; </span> 
       <span id="stats_article_count">文章 - 0&nbsp; </span> 
       <span id="stats-comment_count">评论 - 711</span> 
      </div> 
     </div>
     <!--end: blogStats --> 
    </div>
    <!--end: navigator 博客导航栏 --> 
   </div>
   <!--end: header 头部 --> 
   <div id="main"> 
    <div id="mainContent"> 
     <div class="forFlow"> 
      <div id="post_detail"> 
       <!--done--> 
       <div id="topics"> 
        <div class="post"> 
         <h1 class="postTitle"> <a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/xuanhun/p/6298436.html">老司机教你下载tumblr上视频和图片的正确姿势</a> </h1> 
         <div class="clear"></div> 
         <div class="postBody"> 
          <div id="cnblogs_post_body">
           <h1 id="tumblr">本文面向初学者。</h1> 
           <p>很多同学问我：“我非常想学Python编程，但是找不到兴趣点”。 还有的同学呢，找到了很好的兴趣点，但是无从下手，“玄魂老师，我想下载tumblr上的视频， 怎么下载，Python能实现吗？你懂得（这里有一个淫笑的表情）”。</p> 
           <p>好吧，我表示对他所要表达的意思秒懂了，宅男都喜欢看别人开车。今天本人姑且装一把老司机， 带大家来分析下如何下载tumblr上的图片和视频。请大家准备好纸巾，哦不，是准备好开发工具， 我们开始写代码。</p> 
           <h2 id="11">1.1 需求分析</h2> 
           <p>下载一个站点上的图片和视频，无非就是写一个简易的爬虫，这里我不去使用现有的爬虫框架， 也可以很容易的完成任务。编写指定页面的爬虫，需要对目标页面的HTML结构进行分析，如果 是AJAX请求，需要进行多次的请求分析；如果存在身份验证，则要进一步处理Cookie等数据。一般的 爬虫的基本结构如下图：</p> 
           <p><img style="display: block; margin-left: auto; margin-right: auto;" src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118222353265-564977299.jpg" alt="" /></p> 
           <p><img src="file:///D:/Program%20Files%20(x86)/Microsoft%20VS%20Code/resources/app/out/vs/workbench/parts/html/browser/1.jpg" alt="爬虫基本结构" /></p> 
           <p>即使编写一个最小的爬虫，我们也要有一个任务调度器，用来生成任务条目到队列中， 针对不同的任务类型，要编写不同的下载器。不考虑分布式部署的情况下，每一个下载器（Downloader) 应该在一个线程中执行任务。今天我们的要编写的爬虫略微简单，考虑到入门级同学，过多的 概念就不介绍了，以免发蒙。</p> 
           <blockquote> 
            <p>如果你还不知道Tumblr是什么的话，请百度。 Tumblr（中文名：汤博乐） 成立于2007年，是目前全球最大的轻博客网站，也是轻博客网站的始祖。Tumblr（汤博乐）是一种介于传统博客和微博之间的全新媒体形态，既注重表达，又注重社交，而且注重个性化设置，成为当前最受年轻人欢迎的社交网站之一。雅虎公司董事会2013年5月19日决定，以11亿美元收购Tumblr。</p> 
            <p>这是一个高大上的网站，很多设计师，动图爱好者的聚集地。不过目前需要FQ访问。</p> 
           </blockquote> 
           <p>下面我们来看一下tumblr的个人空间。</p> 
           <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118222411625-800663386.jpg" alt="" width="687" height="402" /></p> 
           <p><img src="file:///D:/Program%20Files%20(x86)/Microsoft%20VS%20Code/resources/app/out/vs/workbench/parts/html/browser/2.jpg" alt="tumblr个人页面" /></p> 
           <p>如图，每个tumblr的个人空间都是一个二级域名，你甚至可以绑定你自己的域名。在个人主页上， 是一个微博式的消息列表，有文字，图片，视频等形式。消息的展现，是页面上的JavaScript脚本 通过请求Tumblr的Api来获取返回信息，然后添加到页面上的。通过API，可以省掉很多麻烦，至少 我们不必分析整个页面的html来提取需要的信息了。</p> 
           <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118222613203-1726557887.jpg" alt="" /></p> 
           <p><img src="file:///D:/Program%20Files%20(x86)/Microsoft%20VS%20Code/resources/app/out/vs/workbench/parts/html/browser/3.jpg" alt="tumblr个人页面" /></p> 
           <p>下面我们看一下接口：</p> 
           <div>
            <img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118222721656-2061780026.jpg" alt="" />
           </div> 
           <p>上面的代码是一个接口模板，第一个参数是要访问的用户空间的用户名；第二个参数是媒体类型， 图片为“photo”，视频为“video”；第三个参数为请求的资源数；第四个参数为从第几个资源开始 请求。 下面我们构造一个photo的请求，看看返回的数据是什么样的。</p> 
           <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118222747546-679796087.jpg" alt="" /></p> 
           <p><img src="file:///D:/Program%20Files%20(x86)/Microsoft%20VS%20Code/resources/app/out/vs/workbench/parts/html/browser/4.jpg" alt="tumblrAPI" /></p> 
           <p>我们看到返回的数据是XML格式的数据，基本的层级为Tumblr&gt;posts&gt;post。图片的URL在post的photo-url字段中，视频与此类似，就不再演示了。 获取到媒体资源的url之后，就可以进行下载了。</p> 
           <p>我们再构造一个video类型的请求。</p> 
           <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118222804125-1340871869.jpg" alt="" /></p> 
           <p><img src="file:///D:/Program%20Files%20(x86)/Microsoft%20VS%20Code/resources/app/out/vs/workbench/parts/html/browser/4.1.jpg" alt="tumblrAPI" /></p> 
           <p>video类型的资源的url，需要从player属性中进行进一步匹配才能得出最后的结果。</p> 
           <p>在具体编码之前，我们需要对可能遇到的技术难点进行一个评估，并找到解决方案。</p> 
           <h2 id="12">1.2 技术点分析</h2> 
           <h3 id="121-http">1.2.1 如何发送http请求</h3> 
           <p>这里推荐 request模块（https://pypi.python.org/pypi/requests/）。在我们要实现的功能 中，直接使用request模块的get方法就可以了。</p> 
           <h3 id="122-xml">1.2.2 如何处理xml数据</h3> 
           <p>使用request模块发送并接收数据之后，要处理返回的XML数据，因为我们只需要获取photo-uri字段的 值就可以了，所以这里推荐使用xmltodict模块（https://pypi.python.org/pypi/xmltodict）。 xmltodic模块，将xml文档处理成类似Json对象，方便我们对数据进行访问。</p> 
           <h3 id="123-queue">1.2.3 如何实现Queue</h3> 
           <p>python中自带Queue模块，可以满足我们目前的队列需求，由于python2.7和python3.0中 对queue模块的命名进行的变更，编程的时候需要注意。如果考虑兼容两个版本的话，可以 考虑引入six模块（https://pypi.python.org/pypi/six）。six模块是一个专门用于解决 从python2.x到python3.x的兼容性问题的模块，它对python版本变更导致到部分模块不能应用的问题 进行了内部处理，需要处理类似兼容问题的时候，可以考虑或者参考该模块的实现方式。</p> 
           <h3 id="124">1.2.4 如何实现多线程</h3> 
           <p>关于Python多线程，请自行搜索相关文章进行学习，例子很多，这里就不详细说明了。</p> 
           <h3 id="125-json">1.2.5 如何处理json</h3> 
           <p>考虑到Tumblr需要FQ访问，如果本机不使用VPN的话，可能需要配置代理，代理采用json配置方式。 处理.使用python内置的json模块（https://docs.python.org/2/library/json.html）就可以了。</p> 
           <h3 id="126">1.2.6 如何使用正则表达式</h3> 
           <p>为了精确匹配url信息，我们需要使用正则表达式对xml数据的中字段值进行进一步处理，使用 内置的re模块（https://docs.python.org/2/library/re.html）就可以了。</p> 
           <h2 id="13">1.3 搭建程序基本框架</h2> 
           <p>通过上面的分析，我们编写一个下载Tumblr图片和视频的简易爬虫已经没有技术障碍了，下面 我们搭建基本框架。</p> 
           <blockquote> 
            <p>以下代码非玄魂原创，参考自https://github.com/dixudx/tumblr-crawler，做了部分修改</p> 
           </blockquote> 
           <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118223031156-1115589036.jpg" alt="" /></p> 
           <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118223038578-1170198912.jpg" alt="" /></p> 
           <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118223044656-1095645671.jpg" alt="" /></p> 
           <div class="cnblogs_code"> 
            <pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">#</span><span style="color: #008000;"> 设置请求超时时间</span>
<span style="color: #008080;"> 2</span> TIMEOUT = 10
<span style="color: #008080;"> 3</span> 
<span style="color: #008080;"> 4</span> <span style="color: #008000;">#</span><span style="color: #008000;"> 尝试次数</span>
<span style="color: #008080;"> 5</span> RETRY = 5
<span style="color: #008080;"> 6</span> 
<span style="color: #008080;"> 7</span> <span style="color: #008000;">#</span><span style="color: #008000;"> 分页请求的起始点</span>
<span style="color: #008080;"> 8</span> START =<span style="color: #000000;"> 0
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span> <span style="color: #008000;">#</span><span style="color: #008000;"> 每页请求个数</span>
<span style="color: #008080;">11</span> MEDIA_NUM = 50
<span style="color: #008080;">12</span> 
<span style="color: #008080;">13</span> <span style="color: #008000;">#</span><span style="color: #008000;"> 并发线程数</span>
<span style="color: #008080;">14</span> THREADS = 10
<span style="color: #008080;">15</span> 
<span style="color: #008080;">16</span> <span style="color: #008000;">#</span><span style="color: #008000;"> 是否下载图片</span>
<span style="color: #008080;">17</span> ISDOWNLOADIMG=<span style="color: #000000;">True
</span><span style="color: #008080;">18</span> 
<span style="color: #008080;">19</span> <span style="color: #008000;">#</span><span style="color: #008000;">是否下载视频</span>
<span style="color: #008080;">20</span> ISDOWNLOADVIDEO=<span style="color: #000000;">True
</span><span style="color: #008080;">21</span> 
<span style="color: #008080;">22</span> <span style="color: #008000;">#</span><span style="color: #008000;">任务执行类</span>
<span style="color: #008080;">23</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> DownloadWorker(Thread):
</span><span style="color: #008080;">24</span>     <span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span>(self, queue, proxies=<span style="color: #000000;">None):
</span><span style="color: #008080;">25</span>         Thread.<span style="color: #800080;">__init__</span><span style="color: #000000;">(self)
</span><span style="color: #008080;">26</span>         self.queue =<span style="color: #000000;"> queue
</span><span style="color: #008080;">27</span>         self.proxies =<span style="color: #000000;"> proxies
</span><span style="color: #008080;">28</span> 
<span style="color: #008080;">29</span>     <span style="color: #0000ff;">def</span><span style="color: #000000;"> run(self):
</span><span style="color: #008080;">30</span>         <span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
</span><span style="color: #008080;">31</span>             medium_type, post, target_folder =<span style="color: #000000;"> self.queue.get()
</span><span style="color: #008080;">32</span> <span style="color: #000000;">            self.download(medium_type, post, target_folder)
</span><span style="color: #008080;">33</span> <span style="color: #000000;">            self.queue.task_done()
</span><span style="color: #008080;">34</span> 
<span style="color: #008080;">35</span>     <span style="color: #0000ff;">def</span><span style="color: #000000;"> download(self, medium_type, post, target_folder):
</span><span style="color: #008080;">36</span>         <span style="color: #0000ff;">pass</span>
<span style="color: #008080;">37</span> 
<span style="color: #008080;">38</span>     <span style="color: #0000ff;">def</span><span style="color: #000000;"> _handle_medium_url(self, medium_type, post):
</span><span style="color: #008080;">39</span>        <span style="color: #0000ff;">pass</span>
<span style="color: #008080;">40</span> 
<span style="color: #008080;">41</span>     <span style="color: #0000ff;">def</span><span style="color: #000000;"> _download(self, medium_type, medium_url, target_folder):
</span><span style="color: #008080;">42</span>        <span style="color: #0000ff;">pass</span>
<span style="color: #008080;">43</span> 
<span style="color: #008080;">44</span> <span style="color: #008000;">#</span><span style="color: #008000;">调度类</span>
<span style="color: #008080;">45</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CrawlerScheduler(object):
</span><span style="color: #008080;">46</span> 
<span style="color: #008080;">47</span>     <span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span>(self, sites, proxies=<span style="color: #000000;">None):
</span><span style="color: #008080;">48</span>         self.sites =<span style="color: #000000;"> sites
</span><span style="color: #008080;">49</span>         self.proxies =<span style="color: #000000;"> proxies
</span><span style="color: #008080;">50</span>         self.queue =<span style="color: #000000;"> Queue.Queue()
</span><span style="color: #008080;">51</span> <span style="color: #000000;">        self.scheduling()
</span><span style="color: #008080;">52</span> 
<span style="color: #008080;">53</span>     <span style="color: #0000ff;">def</span><span style="color: #000000;"> scheduling(self):
</span><span style="color: #008080;">54</span>         <span style="color: #0000ff;">pass</span>
<span style="color: #008080;">55</span> 
<span style="color: #008080;">56</span> 
<span style="color: #008080;">57</span> 
<span style="color: #008080;">58</span>     <span style="color: #0000ff;">def</span><span style="color: #000000;"> download_videos(self, site):
</span><span style="color: #008080;">59</span>         <span style="color: #0000ff;">pass</span>
<span style="color: #008080;">60</span> 
<span style="color: #008080;">61</span>     <span style="color: #0000ff;">def</span><span style="color: #000000;"> download_photos(self, site):
</span><span style="color: #008080;">62</span>         <span style="color: #0000ff;">pass</span>
<span style="color: #008080;">63</span> 
<span style="color: #008080;">64</span>     <span style="color: #0000ff;">def</span><span style="color: #000000;"> _download_media(self, site, medium_type, start):
</span><span style="color: #008080;">65</span>         <span style="color: #0000ff;">pass</span>
<span style="color: #008080;">66</span> 
<span style="color: #008080;">67</span> <span style="color: #008000;">#</span><span style="color: #008000;">程序入口</span>
<span style="color: #008080;">68</span> <span style="color: #008000;">#</span><span style="color: #008000;">初始化配置</span></pre> 
           </div> 
           <p>&nbsp;</p> 
           <p>首先，我们定义了一些全局变量，看注释就明白用途了，不做过多解释。</p> 
           <p>现在看上面的类和方法的定义。DownloadWorker类，执行具体的下载任务，因为每个下载任务 要在单独的线程中完成，所以我们将DownloadWorker类继承Thread类。DownloadWorker接收从CrawlerScheduler 传递过来的Queue，它会从queue中请求任务来执行。同时如果用户配置了代理，在执行http请求的时候会使用代理。 run方法是线程启动方法，它会不停的从queue中请求任务，执行任务。download方法，首先调用_handle_medium_url 方法，获取当前任务的url，然后调用_download方法执行具体的下载任务。</p> 
           <p>CrawlerScheduler类，根据配置中需要处理的用户名，创建任务队列，初始化任务线程，启动线程执行任务。 scheduling方法，创建并启动工作线程，然后调用download_videos和download_photos方法。 download_videos和download_photos方法分别调用_download_media方法，创建具体的任务队列。_download_media 方法，首先根据传入的site创建对应的本地文件夹，然后请求Tumblr的接口，获取用户所有的图片或者视频数据压入队列。</p> 
           <p>除了上面的核心方法之外，我们创建两个配置文件proxies.json和sites.txt文件。proxies.json用来配置 代理，默认为空。</p> 
           <div> 
            <div class="cnblogs_code"> 
             <pre>{}</pre> 
            </div> 
            <p>&nbsp;</p> 
           </div> 
           <p>可以根据你使用的代理，进行具体的配置，比如：</p> 
           <div class="cnblogs_code"> 
            <pre><span style="color: #000000;">{
  </span>&quot;http&quot;: &quot;http://10.10.1.10:3128&quot;<span style="color: #000000;">,
  </span>&quot;https&quot;: &quot;127.0.0.1：8787&quot;<span style="color: #000000;">
}</span></pre> 
           </div> 
           <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118223349890-1095448045.jpg" alt="" /></p> 
           <p>或者</p> 
           <div class="cnblogs_code"> 
            <pre><span style="color: #000000;">{
    </span>&quot;http&quot;: &quot;socks5://user:pass@host:port&quot;<span style="color: #000000;">,
    </span>&quot;https&quot;: &quot;socks5://127.0.0.1:1080&quot;<span style="color: #000000;">
}</span></pre> 
           </div> 
           <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118223355921-935633180.jpg" alt="" /></p> 
           <p>sites.txt文件用来配置我们要请求的用户空间，只需要配置用户名即可，例如：</p> 
           <div> 
            <div class="cnblogs_code"> 
             <pre>want2580,luoli-qaq</pre> 
            </div> 
            <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118223416781-418325498.jpg" alt="" /></p> 
           </div> 
           <h2 id="14">1.4 具体实现</h2> 
           <p>这里大家使用最新的python版本就可以了，安装Python的时候一定要将pip一同安装。 根据1.2节的分析，我们需要安装如下模块：</p> 
           <blockquote> 
            <p>requests&gt;=2.10.0<br />xmltodict<br />six<br />PySocks&gt;=1.5.6</p> 
           </blockquote> 
           <p>为了方便，可以将这些依赖放到一个requirements.txt文件中。</p> 
           <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118223445484-1032646305.jpg" alt="" /></p> 
           <p><img src="file:///D:/Program%20Files%20(x86)/Microsoft%20VS%20Code/resources/app/out/vs/workbench/parts/html/browser/5.jpg" alt="requerments.txt" /></p> 
           <p>然后执行命令:</p> 
           <div>
            pip install -r requirements.txt
           </div> 
           <div>
            <img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118223902234-2021734785.jpg" alt="" />
           </div> 
           <div>
            &nbsp;
           </div> 
           <p>基本环境准备完毕之后，在具体实现逻辑之前先引入依赖的模块。</p> 
           <div class="cnblogs_code"> 
            <pre><span style="color: #008000;">#</span><span style="color: #008000;"> -*- coding: utf-8 -*-</span>

<span style="color: #0000ff;">import</span><span style="color: #000000;"> os
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> sys
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> requests
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> xmltodict
</span><span style="color: #0000ff;">from</span> six.moves <span style="color: #0000ff;">import</span><span style="color: #000000;"> queue as Queue
</span><span style="color: #0000ff;">from</span> threading <span style="color: #0000ff;">import</span><span style="color: #000000;"> Thread
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> re
</span><span style="color: #0000ff;">import</span> json</pre> 
           </div> 
           <p>&nbsp;</p> 
           <div>
            <img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118223929906-679307983.jpg" alt="" />
           </div> 
           <p>下面我们先来完善CrawlerScheduler类的scheduling方法。</p> 
           <div class="cnblogs_code"> 
            <pre><span style="color: #0000ff;">def</span><span style="color: #000000;"> scheduling(self):
        </span><span style="color: #008000;">#</span><span style="color: #008000;"> 创建工作线程</span>
        <span style="color: #0000ff;">for</span> x <span style="color: #0000ff;">in</span><span style="color: #000000;"> range(THREADS):
            worker </span>=<span style="color: #000000;"> DownloadWorker(self.queue,
                                    proxies</span>=<span style="color: #000000;">self.proxies)
            </span><span style="color: #008000;">#</span><span style="color: #008000;">设置daemon属性，保证主线程在任何情况下可以退出</span>
            worker.daemon =<span style="color: #000000;"> True
            worker.start()

        </span><span style="color: #0000ff;">for</span> site <span style="color: #0000ff;">in</span><span style="color: #000000;"> self.sites:
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> ISDOWNLOADIMG:
                self.download_photos(site)
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> ISDOWNLOADVIDEO:
                self.download_videos(site)</span></pre> 
           </div> 
           <p>&nbsp;</p> 
           <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118223939484-1387556427.jpg" alt="" /></p> 
           <pre class="hljs"></pre> 
           <p>根据全局变量THREADS定义的最大线程数，创建DownloadWorker对象，并调用start方法，启动线程。 接下来根据传入的sites，循环调用download_photos和download_videos方法。下面我们看download_photos和download_videos方法 的实现。</p> 
           <div class="cnblogs_code"> 
            <pre> <span style="color: #0000ff;">def</span><span style="color: #000000;"> download_videos(self, site):
        self._download_media(site, </span><span style="color: #800000;">&quot;</span><span style="color: #800000;">video</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">, START)
        </span><span style="color: #008000;">#</span><span style="color: #008000;"> 等待queue处理完一个用户的所有请求任务项</span>
<span style="color: #000000;">        self.queue.join()
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">&quot;</span><span style="color: #800000;">视频下载完成 %s</span><span style="color: #800000;">&quot;</span> %<span style="color: #000000;"> site)

    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> download_photos(self, site):
        self._download_media(site, </span><span style="color: #800000;">&quot;</span><span style="color: #800000;">photo</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">, START)
         </span><span style="color: #008000;">#</span><span style="color: #008000;"> 等待queue处理完一个用户的所有请求任务项</span>
<span style="color: #000000;">        self.queue.join()
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">&quot;</span><span style="color: #800000;">图片下载完成 %s</span><span style="color: #800000;">&quot;</span> % site)</pre> 
           </div> 
           <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118224133218-392652956.jpg" alt="" /></p> 
           <p>这两个方法，只是调用了_download_media方法，传入各自的类型，和分页请求的其实索引值，目前都是从0开始。 下面看核心的_download_media方法。</p> 
           <div class="cnblogs_code"> 
            <pre><span style="color: #0000ff;">def</span><span style="color: #000000;"> _download_media(self, site, medium_type, start):
        </span><span style="color: #008000;">#</span><span style="color: #008000;">创建存储目录</span>
        current_folder =<span style="color: #000000;"> os.getcwd()
        target_folder </span>=<span style="color: #000000;"> os.path.join(current_folder, site)
        </span><span style="color: #0000ff;">if</span> <span style="color: #0000ff;">not</span><span style="color: #000000;"> os.path.isdir(target_folder):
            os.mkdir(target_folder)

        base_url </span>= <span style="color: #800000;">&quot;</span><span style="color: #800000;">http://{0}.tumblr.com/api/read?type={1}&amp;num={2}&amp;start={3}</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">
        start </span>=<span style="color: #000000;"> START
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
            media_url </span>=<span style="color: #000000;"> base_url.format(site, medium_type, MEDIA_NUM, start)
            response </span>=<span style="color: #000000;"> requests.get(media_url,
                                    proxies</span>=<span style="color: #000000;">self.proxies)
            data </span>=<span style="color: #000000;"> xmltodict.parse(response.content)
            </span><span style="color: #0000ff;">try</span><span style="color: #000000;">:
                posts </span>= data[<span style="color: #800000;">&quot;</span><span style="color: #800000;">tumblr</span><span style="color: #800000;">&quot;</span>][<span style="color: #800000;">&quot;</span><span style="color: #800000;">posts</span><span style="color: #800000;">&quot;</span>][<span style="color: #800000;">&quot;</span><span style="color: #800000;">post</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">]
                </span><span style="color: #0000ff;">for</span> post <span style="color: #0000ff;">in</span><span style="color: #000000;"> posts:
                    </span><span style="color: #008000;">#</span><span style="color: #008000;"> select the largest resolution</span>
                    <span style="color: #008000;">#</span><span style="color: #008000;"> usually in the first element</span>
<span style="color: #000000;">                    self.queue.put((medium_type, post, target_folder))
                start </span>+=<span style="color: #000000;"> MEDIA_NUM
            </span><span style="color: #0000ff;">except</span><span style="color: #000000;"> KeyError:
                </span><span style="color: #0000ff;">break</span></pre> 
           </div> 
           <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118224157703-497305250.jpg" alt="" /></p> 
           <p>_download_media方法，会在当前程序执行目录创建以用户名命名的子文件夹，用来存储图片和视频文件。这里 使用os.getcwd()来获取当前程序执行的觉得路径，然后通过os.path.join(current_folder, site)构造目标文件夹 路径，通过os.path.isdir(target_folder)来判断是否已经存在该文件夹，如果没有则通过os.mkdir(target_folder) 创建文件夹。</p> 
           <p>接下来，_download_media方法循环进行分页请求，来获取图片或视频资源信息。通过requests.get(media_url,proxies=self.proxies) 发送http get请求，通过response.content获取返回的数据，然后利用xmltodict.parse(response.content)来 反序列化xml数据到data对象。调用 data[&quot;tumblr&quot;][&quot;posts&quot;][&quot;post&quot;]，获取当前返回数据中的所有媒体资源。 然后循环调用self.queue.put((medium_type, post, target_folder))方法，将每一个post字段压入队列。此时压入队列的post包含了 一个图片或者视频的各项数据，需要在worker线程执行的时候进一步处理才能得到具体的url，后面我们继续分析。</p> 
           <p>scheduling类的实现已经完成了，在scheduling类的scheduling方法中启动了线程，每个worker对象的run方法 都会执行。</p> 
           <div class="cnblogs_code"> 
            <pre>   <span style="color: #0000ff;">def</span><span style="color: #000000;"> run(self):
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
            medium_type, post, target_folder </span>=<span style="color: #000000;"> self.queue.get()
            self.download(medium_type, post, target_folder)
            self.queue.task_done()</span></pre> 
           </div> 
           <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118224223000-210552504.jpg" alt="" /></p> 
           <p>run 方法，通过self.queue.get()方法，从任务队列中获取一条任务，每个任务包含媒体类型（图片或则视频）， 每个媒体的post信息以及下载文件保存的目标文件夹。run方法将这些信息传入download方法。</p> 
           <div class="cnblogs_code"> 
            <pre> <span style="color: #0000ff;">def</span><span style="color: #000000;"> download(self, medium_type, post, target_folder):
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;">:
            medium_url </span>=<span style="color: #000000;"> self._handle_medium_url(medium_type, post)
            </span><span style="color: #0000ff;">if</span> medium_url <span style="color: #0000ff;">is</span> <span style="color: #0000ff;">not</span><span style="color: #000000;"> None:
                self._download(medium_type, medium_url, target_folder)
        </span><span style="color: #0000ff;">except</span><span style="color: #000000;"> TypeError:
            </span><span style="color: #0000ff;">pass</span></pre> 
           </div> 
           <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118224245328-2064508931.jpg" alt="" /></p> 
           <p>download方法首先通过_handle_medium_url方法获取具体的资源的url，然后调用_download执行下载。</p> 
           <div class="cnblogs_code"> 
            <pre><span style="color: #0000ff;">def</span><span style="color: #000000;"> _handle_medium_url(self, medium_type, post):
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;">:
            </span><span style="color: #0000ff;">if</span> medium_type == <span style="color: #800000;">&quot;</span><span style="color: #800000;">photo</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">:
                </span><span style="color: #0000ff;">return</span> post[<span style="color: #800000;">&quot;</span><span style="color: #800000;">photo-url</span><span style="color: #800000;">&quot;</span>][0][<span style="color: #800000;">&quot;</span><span style="color: #800000;">#text</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">]

            </span><span style="color: #0000ff;">if</span> medium_type == <span style="color: #800000;">&quot;</span><span style="color: #800000;">video</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">:
                video_player </span>= post[<span style="color: #800000;">&quot;</span><span style="color: #800000;">video-player</span><span style="color: #800000;">&quot;</span>][1][<span style="color: #800000;">&quot;</span><span style="color: #800000;">#text</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">]
                hd_pattern </span>= re.compile(r<span style="color: #800000;">'</span><span style="color: #800000;">.*&quot;hdUrl&quot;:(&quot;([^\s,]*)&quot;|false),</span><span style="color: #800000;">'</span><span style="color: #000000;">)
                hd_match </span>=<span style="color: #000000;"> hd_pattern.match(video_player)
                </span><span style="color: #0000ff;">try</span><span style="color: #000000;">:
                    </span><span style="color: #0000ff;">if</span> hd_match <span style="color: #0000ff;">is</span> <span style="color: #0000ff;">not</span> None <span style="color: #0000ff;">and</span> hd_match.group(1) != <span style="color: #800000;">'</span><span style="color: #800000;">false</span><span style="color: #800000;">'</span><span style="color: #000000;">:
                        </span><span style="color: #0000ff;">return</span> hd_match.group(2).replace(<span style="color: #800000;">'</span><span style="color: #800000;">\\</span><span style="color: #800000;">'</span>, <span style="color: #800000;">''</span><span style="color: #000000;">)
                </span><span style="color: #0000ff;">except</span><span style="color: #000000;"> IndexError:
                    </span><span style="color: #0000ff;">pass</span><span style="color: #000000;">
                pattern </span>= re.compile(r<span style="color: #800000;">'</span><span style="color: #800000;">.*src=&quot;(\S*)&quot; </span><span style="color: #800000;">'</span><span style="color: #000000;">, re.DOTALL)
                match </span>=<span style="color: #000000;"> pattern.match(video_player)
                </span><span style="color: #0000ff;">if</span> match <span style="color: #0000ff;">is</span> <span style="color: #0000ff;">not</span><span style="color: #000000;"> None:
                    </span><span style="color: #0000ff;">try</span><span style="color: #000000;">:
                        </span><span style="color: #0000ff;">return</span> match.group(1<span style="color: #000000;">)
                    </span><span style="color: #0000ff;">except</span><span style="color: #000000;"> IndexError:
                        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> None
        </span><span style="color: #0000ff;">except</span><span style="color: #000000;">:
            </span><span style="color: #0000ff;">raise</span> TypeError(<span style="color: #800000;">&quot;</span><span style="color: #800000;">找不到正确的下载URL </span><span style="color: #800000;">&quot;</span>
                            <span style="color: #800000;">&quot;</span><span style="color: #800000;">请到 </span><span style="color: #800000;">&quot;</span>
                            <span style="color: #800000;">&quot;</span><span style="color: #800000;">https://github.com/xuanhun/tumblr-crawler</span><span style="color: #800000;">&quot;</span>
                            <span style="color: #800000;">&quot;</span><span style="color: #800000;">提交错误信息:\n\n</span><span style="color: #800000;">&quot;</span>
                            <span style="color: #800000;">&quot;</span><span style="color: #800000;">%s</span><span style="color: #800000;">&quot;</span> % post)</pre> 
           </div> 
           <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118224312734-243213509.jpg" alt="" /></p> 
           <p>_handle_medium_url方法，根据媒体的不同采用了不同的资源获取方法。不过获取图片的方法这里还是有缺陷的， 因为用户在一个post中可能会发送一组图片，目前的方法只处理了第一张图片。如果是视频，先取出video-player 的文本内容，然后通过正则表达式匹配出视频的url，具体匹配原理，你只要参考视频请求返回的xml内容就明白了， 这里就不详细分析了。下面我们看如何下载资源。</p> 
           <div class="cnblogs_code"> 
            <pre><span style="color: #0000ff;">def</span><span style="color: #000000;"> _download(self, medium_type, medium_url, target_folder):
        medium_name </span>= medium_url.split(<span style="color: #800000;">&quot;</span><span style="color: #800000;">/</span><span style="color: #800000;">&quot;</span>)[-1].split(<span style="color: #800000;">&quot;</span><span style="color: #800000;">?</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">)[0]
        </span><span style="color: #0000ff;">if</span> medium_type == <span style="color: #800000;">&quot;</span><span style="color: #800000;">video</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">:
            </span><span style="color: #0000ff;">if</span> <span style="color: #0000ff;">not</span> medium_name.startswith(<span style="color: #800000;">&quot;</span><span style="color: #800000;">tumblr</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">):
                medium_name </span>= <span style="color: #800000;">&quot;</span><span style="color: #800000;">_</span><span style="color: #800000;">&quot;</span>.join([medium_url.split(<span style="color: #800000;">&quot;</span><span style="color: #800000;">/</span><span style="color: #800000;">&quot;</span>)[-2<span style="color: #000000;">],
                                        medium_name])

            medium_name </span>+= <span style="color: #800000;">&quot;</span><span style="color: #800000;">.mp4</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">

        file_path </span>=<span style="color: #000000;"> os.path.join(target_folder, medium_name)
        </span><span style="color: #0000ff;">if</span> <span style="color: #0000ff;">not</span><span style="color: #000000;"> os.path.isfile(file_path):
            </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">&quot;</span><span style="color: #800000;">Downloading %s from %s.\n</span><span style="color: #800000;">&quot;</span> %<span style="color: #000000;"> (medium_name,
                                                 medium_url))
            retry_times </span>=<span style="color: #000000;"> 0
            </span><span style="color: #0000ff;">while</span> retry_times &lt;<span style="color: #000000;"> RETRY:
                </span><span style="color: #0000ff;">try</span><span style="color: #000000;">:
                    resp </span>=<span style="color: #000000;"> requests.get(medium_url,
                                        stream</span>=<span style="color: #000000;">True,
                                        proxies</span>=<span style="color: #000000;">self.proxies,
                                        timeout</span>=<span style="color: #000000;">TIMEOUT)
                    with open(file_path, </span><span style="color: #800000;">'</span><span style="color: #800000;">wb</span><span style="color: #800000;">'</span><span style="color: #000000;">) as fh:
                        </span><span style="color: #0000ff;">for</span> chunk <span style="color: #0000ff;">in</span> resp.iter_content(chunk_size=1024<span style="color: #000000;">):
                            fh.write(chunk)
                    </span><span style="color: #0000ff;">break</span>
                <span style="color: #0000ff;">except</span><span style="color: #000000;">:
                    </span><span style="color: #008000;">#</span><span style="color: #008000;"> try again</span>
                    <span style="color: #0000ff;">pass</span><span style="color: #000000;">
                retry_times </span>+= 1
            <span style="color: #0000ff;">else</span><span style="color: #000000;">:
                </span><span style="color: #0000ff;">try</span><span style="color: #000000;">:
                    os.remove(file_path)
                </span><span style="color: #0000ff;">except</span><span style="color: #000000;"> OSError:
                    </span><span style="color: #0000ff;">pass</span>
                <span style="color: #0000ff;">print</span>(<span style="color: #800000;">&quot;</span><span style="color: #800000;">Failed to retrieve %s from %s.\n</span><span style="color: #800000;">&quot;</span> %<span style="color: #000000;"> (medium_type,
                                                            medium_url))</span></pre> 
           </div> 
           <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118224339875-562971970.jpg" alt="" /></p> 
           <p>_download方法先构造存储文件的路径，如果文件存在则不再反复下载，这样可以保证在下载出现错误的情况下， 我们可以手动重启程序，多次下载。通过</p> 
           <div> 
            <div class="cnblogs_code"> 
             <pre>resp =<span style="color: #000000;"> requests.get(medium_url,
                                        stream</span>=<span style="color: #000000;">True,
                                        proxies</span>=<span style="color: #000000;">self.proxies,
                                        timeout</span>=TIMEOUT)</pre> 
            </div> 
            <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118224419734-974916313.jpg" alt="" /></p> 
           </div> 
           <p>发送get请求，获取流数据，然后每次从流中请求1024bit数据写入磁盘，直到流结束为止：</p> 
           <div> 
            <div class="cnblogs_code"> 
             <pre> with open(file_path, <span style="color: #800000;">'</span><span style="color: #800000;">wb</span><span style="color: #800000;">'</span><span style="color: #000000;">) as fh:
                        </span><span style="color: #0000ff;">for</span> chunk <span style="color: #0000ff;">in</span> resp.iter_content(chunk_size=1024<span style="color: #000000;">):
                            fh.write(chunk)</span></pre> 
            </div> 
            <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118224442343-289365090.jpg" alt="" /></p> 
           </div> 
           <p>至此所有核心代码都完善完毕，是不是很简单呢？确实很简单，这就是Python的强大之处。最后我们完善下程序的入口。</p> 
           <div class="cnblogs_code"> 
            <pre><span style="color: #0000ff;">def</span><span style="color: #000000;"> usage():
    </span><span style="color: #0000ff;">print</span>(u<span style="color: #800000;">&quot;</span><span style="color: #800000;">未找到sites.txt文件，请创建.\n</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">
          u</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">请在文件中指定Tumblr站点名，并以逗号分割，不要有空格.\n</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">
          u</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">保存文件并重试.\n\n</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">
          u</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">例子: site1,site2\n\n</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">
          u</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">或者直接使用命令行参数指定站点\n</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">
          u</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">例子: python tumblr-photo-video-ripper.py site1,site2</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">)


</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> illegal_json():
    </span><span style="color: #0000ff;">print</span>(u<span style="color: #800000;">&quot;</span><span style="color: #800000;">文件proxies.json格式非法.\n</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">
          u</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">请参照示例文件'proxies_sample1.json'和'proxies_sample2.json'.\n</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">
          u</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">然后去 http://jsonlint.com/ 进行验证.</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">)


</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">&quot;</span><span style="color: #800000;">__main__</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">:
    sites </span>=<span style="color: #000000;"> None

    proxies </span>=<span style="color: #000000;"> None
    </span><span style="color: #0000ff;">if</span> os.path.exists(<span style="color: #800000;">&quot;</span><span style="color: #800000;">./proxies.json</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">):
        with open(</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">./proxies.json</span><span style="color: #800000;">&quot;</span>, <span style="color: #800000;">&quot;</span><span style="color: #800000;">r</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">) as fj:
            </span><span style="color: #0000ff;">try</span><span style="color: #000000;">:
                proxies </span>=<span style="color: #000000;"> json.load(fj)
                </span><span style="color: #0000ff;">if</span> proxies <span style="color: #0000ff;">is</span> <span style="color: #0000ff;">not</span> None <span style="color: #0000ff;">and</span> len(proxies) &gt;<span style="color: #000000;"> 0:
                    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">&quot;</span><span style="color: #800000;">You are using proxies.\n%s</span><span style="color: #800000;">&quot;</span> %<span style="color: #000000;"> proxies)
            </span><span style="color: #0000ff;">except</span><span style="color: #000000;">:
                illegal_json()
                sys.exit(</span>1<span style="color: #000000;">)

    </span><span style="color: #0000ff;">if</span> len(sys.argv) &lt; 2<span style="color: #000000;">:
        </span><span style="color: #008000;">#</span><span style="color: #008000;">校验sites配置文件</span>
        filename = <span style="color: #800000;">&quot;</span><span style="color: #800000;">sites.txt</span><span style="color: #800000;">&quot;</span>
        <span style="color: #0000ff;">if</span><span style="color: #000000;"> os.path.exists(filename):
            with open(filename, </span><span style="color: #800000;">&quot;</span><span style="color: #800000;">r</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">) as f:
                sites </span>= f.read().rstrip().lstrip().split(<span style="color: #800000;">&quot;</span><span style="color: #800000;">,</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">)
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;">:
            usage()
            sys.exit(</span>1<span style="color: #000000;">)
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;">:
        sites </span>= sys.argv[1].split(<span style="color: #800000;">&quot;</span><span style="color: #800000;">,</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">)

    </span><span style="color: #0000ff;">if</span> len(sites) == 0 <span style="color: #0000ff;">or</span> sites[0] == <span style="color: #800000;">&quot;&quot;</span><span style="color: #000000;">:
        usage()
        sys.exit(</span>1<span style="color: #000000;">)

    CrawlerScheduler(sites, proxies</span>=proxies)</pre> 
           </div> 
           <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118224511125-494293043.jpg" alt="" /></p> 
           <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118224520578-1650701151.jpg" alt="" /></p> 
           <p>&nbsp;</p> 
           <p>我们定义了usage方法，提示用户如何使用，illegal_json方法提示代理配置错误。 在程序的入口处，先判断是否有代理配置，如果有则取出信息。sites的配置支持从文件和命令行参数传入两种方式。最后 初始化CrawlerScheduler，启动抓取程序。</p> 
           <hr /> 
           <h2 id="15">1.5 小结</h2> 
           <p>至此，程序构造完毕，总共才200行左右的代码，没有什么能阻挡荷尔蒙的迸发，进军吧，少年们，把撸鸡鸡的手解放出来撸撸代码，你也能做老司机！ 玩笑归玩笑，希望这能激发你编程的欲望，自己动手敲一敲，会学到很多的，也许就爱上编程了呢。</p> 
           <p><img src="http://images2015.cnblogs.com/blog/42533/201701/42533-20170118224548265-1985913527.jpg" alt="" /></p> 
           <p><img src="file:///D:/Program%20Files%20(x86)/Microsoft%20VS%20Code/resources/app/out/vs/workbench/parts/html/browser/6.jpg" alt="tumblr" /></p> 
           <p>最后，全部完整代码，我已经放到github上了（https://github.com/xuanhun/tumblr-crawler），如果你在微信中阅读本文，点击阅读原文，可以跳转过去。我认为我已经 讲解的够详细了，同时源代码已经给到了，你还是搞不定的话，只能说编程不适合你。当然，不能勉强所有人都喜欢 编程，我把这个代码打包成了exe工具，作为宅男福利，作为对不劳而获的惩罚，你需要在微信订阅号（xuanhun521）本篇文章下面打赏&gt;=10元，我会在微信订阅号后台统一回复给你工具包和使用方法。</p> 
           <p>请关注微信订阅号（xuanhun521，下方二维码），回复“python”，可查看更多python基础及黑客编程内容。问题讨论请加qq群：Hacking&nbsp;（1群）：303242737&nbsp;&nbsp; Hacking&nbsp;（2群）：147098303。</p> 
           <p align="center">&nbsp;<img src="http://images2015.cnblogs.com/blog/42533/201610/42533-20161024184346593-1661335287.jpg" alt="" /></p> 
           <p align="center">玄魂工作室-精彩不断</p> 
           <p>&nbsp;</p>
          </div>
          <div id="MySignature"></div> 
          <div class="clear"></div> 
          <div id="blog_post_info_block"> 
           <div id="BlogPostCategory"></div> 
           <div id="EntryTag"></div> 
           <div id="blog_post_info"> 
           </div> 
           <div class="clear"></div> 
           <div id="post_next_prev"></div> 
          </div> 
         </div> 
         <div class="postDesc">
          posted @ 
          <span id="post-date">2017-01-18 22:54</span> 
          <a href="http://www.cnblogs.com/xuanhun/">玄魂</a> 阅读(
          <span id="post_view_count">...</span>) 评论(
          <span id="post_comment_count">...</span>) 
          <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6298436" rel="nofollow">编辑</a> 
          <a href="#" onclick="AddToWz(6298436);return false;">收藏</a>
         </div> 
        </div> 
        <script type="text/javascript">var allowComments=true,cb_blogId=46115,cb_entryId=6298436,cb_blogApp=currentBlogApp,cb_blogUserGuid='f0fa460b-63cf-dd11-9e4d-001cf0cd104b',cb_entryCreatedDate='2017/1/18 22:54:00';loadViewCount(cb_entryId);</script> 
       </div>
       <!--end: topics 文章、评论容器--> 
      </div>
      <a name="!comments"></a>
      <div id="blog-comments-placeholder"></div>
      <script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script> 
      <div id="comment_form" class="commentform"> 
       <a name="commentform"></a> 
       <div id="divCommentShow"></div> 
       <div id="comment_nav">
        <span id="span_refresh_tips"></span>
        <a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a>
        <a href="#" onclick="return RefreshPage();">刷新页面</a>
        <a href="#top">返回顶部</a>
       </div> 
       <div id="comment_form_container"></div> 
       <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div> 
       <div id="ad_t2"></div> 
       <div id="opt_under_post"></div> 
       <div id="ad_c1" class="c_ad_block"></div> 
       <div id="under_post_news"></div> 
       <div id="ad_c2" class="c_ad_block"></div> 
       <div id="under_post_kb"></div> 
       <div id="HistoryToday" class="c_ad_block"></div> 
       <script type="text/javascript">
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverAdT2();
    deliverAdC1();
    deliverAdC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);   
</script> 
      </div> 
     </div>
     <!--end: forFlow --> 
    </div>
    <!--end: mainContent 主体内容容器--> 
    <div id="sideBar"> 
     <div id="sideBarMain"> 
      <!--done--> 
      <div class="newsItem"> 
       <h3 class="catListTitle">公告</h3> 
       <div id="blog-news"></div>
       <script type="text/javascript">loadBlogNews();</script> 
      </div> 
      <div id="blog-calendar" style="display:none"></div>
      <script type="text/javascript">loadBlogDefaultCalendar();</script> 
      <div id="leftcontentcontainer"> 
       <div id="blog-sidecolumn"></div>
       <script type="text/javascript">loadBlogSideColumn();</script> 
      </div> 
     </div>
     <!--end: sideBarMain --> 
    </div>
    <!--end: sideBar 侧边栏容器 --> 
    <div class="clear"></div> 
   </div>
   <!--end: main --> 
   <div class="clear"></div> 
   <div id="footer"> 
    <!--done--> Copyright &copy;2017 玄魂 
   </div>
   <!--end: footer --> 
  </div>
  <!--end: home 自定义的最大容器 -->   
 </body>
</html>
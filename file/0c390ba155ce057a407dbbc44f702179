<!DOCTYPE html>
<html>
 <head> 
  <meta http-equiv="content-type" content="text/html;charset=utf-8" /> 
  <title>Spring 实践 -AOP_Spring_Java-ITnose</title> 
  <meta name="keywords" content="Spring 实践 -AOP" /> 
  <meta name="description" content="Spring 实践 -AOP" /> 
  <link rel="stylesheet" type="text/css" href="/cssfile/detail.css" /> 
  <script type="text/javascript" src="/Scripts/jquery.js"></script> 
  <!--[if lte IE 8]><script>(function(){ var e="abbr,article,aside,audio,canvas,datalist,details,dialog,eventsource,figure,footer,header,hgroup,mark,menu,meter,nav,output,progress,section,time,video".split(","),i=e.length;while(i--){document.createElement(e[i])}})();</script><![endif]--> 
 </head> 
 <body class="body-slei-center"> 
  <div class="line"> 
   <div id="userbar" class="userbar"> 
    <ul class="main-list"> 
     <li></li> 
    </ul> 
   </div> 
  </div> 
  <header id="header" class="container"> 
   <div id="top-box-slei" class="top-box-slei line pt-20"> 
    <a class="logo" href="/" title="logo"></a> 
    <ul class="channel"></ul> 
    <form action="/s.do" method="get" class="search-form"> 
     <div class="box"> 
      <span class="top-box-slei-bg"></span> 
      <input class="hdi" id="itnosekw" maxlength="256" tabindex="1" size="46" name="kw" value="" /> 
      <span class="btn-wrap"><input type="submit" tabindex="2" value="搜索文章" class="btn-global" /></span> 
     </div> 
    </form> 
   </div> 
  </header> 
  <div id="body" class="container"> 
   <div id="menu" class="menu"> 
    <ul> 
     <li class="current ml-10"><a href="/"> 首页 </a></li> 
     <li><a href="/type/1.html">J2SE</a></li> 
     <li><a href="/type/2.html">JavaEclipse</a></li> 
     <li><a href="/type/3.html">J2EE</a></li> 
     <li><a href="/type/4.html">jsp</a></li> 
     <li><a href="/type/6.html">Hibernate</a></li> 
     <li><a href="/type/7.html"><font color="#FFFF00">Spring</font></a></li> 
     <li><a href="/type/8.html">JAVA程序员</a></li> 
     <li><a href="/type/9.html">EJB</a></li> 
     <li><a href="/type/10.html">JAVA基础类</a></li> 
     <li><a href="/type/11.html">JavaWeb</a></li> 
     <li><a href="/type/12.html">J2ME</a></li> 
     <li><a href="/type/13.html">java其它相关</a></li> 
     <li><a href="/type/114.html">struts</a></li> 
     <li><a href="/type/141.html">NetBeans</a></li> 
     <li><a href="/type/165.html">JFinal</a></li> 
     <li><a href="/type/154.html">Mybatis</a></li> 
     <li><a href="/type/146.html">TeamCity</a></li> 
     <li><a href="/type/147.html">Maven</a></li> 
     <li><a href="/type/150.html">HibernateSearch</a></li> 
     <li><a href="/type/117.html">Tomcat</a></li> 
     <li><a href="/type/178.html">Netty</a></li> 
     <li><a href="/type/180.html">Jetty</a></li> 
    </ul> 
   </div> 
   <div style="margin-top:10px;border: 1px solid #CCC;background-color: #FFF;width: 1088px;padding:5px 5px 0px 5px;height:100px"> 
    <script type="text/javascript">
    var cpro_id = "u1737258";
</script> 
    <script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script> 
   </div> 
   <div> 
    <div> 
     <nav> 
      <a href="/">ITnose首页</a> &gt; 
      <a href="/union/1.html">Java</a> &gt; 
      <a href="/type/7.html">Spring</a> &gt; 
     </nav> 
    </div> 
    <section class="line qb-section"> 
     <article class="grid qb-content" id="qb-content"> 
      <div class="wgt-ask" style="background-color:#FFF;"> 
       <h1 class="title"> <span class="title"><a href="/detail/6464416.html">Spring 实践 -AOP</a></span> </h1> 
       <div class="line f-aid mb-10"> 
        <span class="grid-r ask-time">2016-03-07 08:46</span> 
        <div class="bdsharebuttonbox">
         <a href="#" class="bds_more" data-cmd="more"></a>
         <a title="分享到QQ空间" href="#" class="bds_qzone" data-cmd="qzone"></a>
         <a title="分享到新浪微博" href="#" class="bds_tsina" data-cmd="tsina"></a>
         <a title="分享到腾讯微博" href="#" class="bds_tqq" data-cmd="tqq"></a>
         <a title="分享到人人网" href="#" class="bds_renren" data-cmd="renren"></a>
         <a title="分享到微信" href="#" class="bds_weixin" data-cmd="weixin"></a>
        </div> 
        <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script> 
       </div> 
       <div class="bd line mt-10 q-content"> 
        <div class="sycode"> 
         <div class="sycode"> 
          <div class="sycode">
            Spring 实践 
           <p>标签： Java与设计模式</p> 
           <h2>AOP引介</h2> 
           <p>AOP(Aspect Oriented Programing)<strong>面向切面编程</strong>采用<strong>横向抽取机制</strong>,以取代传统的<strong>纵向继承体系</strong>的重复性代码(如性能监控/事务管理/安全检查/缓存实现等).</p> 
           <p>横向抽取代码复用: 基于代理技术,在不修改原来代码的前提下,对原有方法进行增强.</p> 
           <h3>Spring AOP 历史</h3> 
           <li>1.2开始, Spring开始支持AOP技术(Spring AOP) <br /> Spring AOP使用纯Java实现,不需要专门的编译过程和类加载器,在运行期通过代理方式向目标类<strong>织入</strong>增强代码.</li> 
           <li>2.0之后, 为了简化AOP开发, Spring开始支持AspectJ(一个基于Java的AOP框架)框架.</li> 
           <h3>AOP相关术语</h3> 
           <table> 
            <tbody>
             <tr>
               术语 中文 描述 
             </tr> 
             <tr> 
              <td>Joinpoint</td> 
              <td>连接点</td> 
              <td>指那些被拦截到的点.在Spring中,这些点指方法(因为Spring只支持方法类型的连接点).</td> 
             </tr> 
             <tr> 
              <td>Pointcut</td> 
              <td>切入点</td> 
              <td>指需要(配置)被增强的Joinpoint.</td> 
             </tr> 
             <tr> 
              <td>Advice</td> 
              <td>通知/增强</td> 
              <td>指拦截到Joinpoint后要做的<strong>操作</strong>.通知分为前置通知/后置通知/异常通知/最终通知/环绕通知等.</td> 
             </tr> 
             <tr> 
              <td>Aspect</td> 
              <td>切面</td> 
              <td>切入点和通知的结合.</td> 
             </tr> 
             <tr> 
              <td>Target</td> 
              <td>目标对象</td> 
              <td>需要被代理(增强)的对象.</td> 
             </tr> 
             <tr> 
              <td>Proxy</td> 
              <td>代理对象</td> 
              <td>目标对象被AOP <strong>织入</strong> 增强/通知后,产生的对象.</td> 
             </tr> 
             <tr> 
              <td>Weaving</td> 
              <td>织入</td> 
              <td>指把<strong>增强/通知</strong>应用到<strong>目标对象</strong>来创建<strong>代理对象</strong>的过程(Spring采用动态代理织入,AspectJ采用编译期织入和类装载期织入).</td> 
             </tr> 
             <tr> 
              <td>Introduction</td> 
              <td>引介</td> 
              <td>一种特殊通知,在不修改类代码的前提下,可以在运行期为类动态地添加一些Method/Field(不常用).</td> 
             </tr> 
            </tbody>
           </table> 
           <p>其他关于AOP理论知识可参考AOP技术研究.</p> 
           <h3>AOP实现</h3> 
           <p>Spring AOP代理实现有两种:<strong>JDK动态代理</strong>和<strong>Cglib框架动态代理</strong>, JDK动态代理可以参考博客代理模式的动态代理部分, 在这里仅介绍CGLib框架实现.</p> 
           <h3>cglib 动态代理</h3> 
           <p>cglib(Code Generation Library)是一个开源/高性能/高质量的Code生成类库,可以在运行期动态扩展Java类与实现Java接口. <br /> cglib比java.lang.reflect.Proxy更强的在于它<strong>不仅可以接管接口类的方法,还可以接管普通类的方法</strong>(cglib<a href="https://github.com/cglib/cglib" rel="nofollow" target="_blank">项目</a>).从3.2开始, spring-core包中内置cglib类,因此可以不用添加额外依赖.</p> 
           <li>UserDAO(并没有实现接口)</li> 
           <pre class="sycode">/**
 * @author jifang
 * @since 16/3/3 上午11:16.
 */
public class UserDAO {

    public void add(Object o) {
        System.out.println(&quot;UserDAO -&gt; Add: &quot; + o.toString());
    }

    public void get(Object o) {
        System.out.println(&quot;UserDAO -&gt; Get: &quot; + o.toString());
    }
}</pre> 
           <li>CGLibProxyFactory</li> 
           <pre class="sycode">public class CGLibProxyFactory {

    private Object target;

    public CGLibProxyFactory(Object target) {
        this.target = target;
    }


    private Callback callback = new MethodInterceptor() {

        /**
 *
 * @param obj 代理对象
 * @param method 当期调用方法
 * @param args 方法参数
 * @param proxy 被调用方法的代理对象(用于执行父类的方法)
 * @return
 * @throws Throwable
 */
        @Override
        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {

            // 前置增强
            System.out.println(&quot;+ Before Advice ...&quot;);

            // 执行目标方法
            //Object result = method.invoke(target, args);
            Object result = proxy.invoke(target, args);

            // 后置增强
            System.out.println(&quot;+ After Advice ...&quot;);

            return result;
        }
    };

    public Object createProxy() {

        // 1. 创建Enhancer对象
        Enhancer enhancer = new Enhancer();

        // 2. cglib创建代理, 对目标对象创建子对象
        enhancer.setSuperclass(target.getClass());

        // 3. 传入回调接口, 对目标增强
        enhancer.setCallback(callback);

        return enhancer.create();
    }

    public static void main(String[] args) {
        UserDAO proxy = (UserDAO) new CGLibProxyFactory(new UserDAO()).createProxy();
        proxy.get(&quot;hello&quot;);
        proxy.add(&quot;world&quot;);
    }
}</pre> 
           <h3>AOP小结</h3> 
           <li>Spring AOP的底层通过JDK/cglib动态代理为目标对象进行横向织入: <br /> 1) 若目标对象实现了接口,则Spring使用JDK的java.lang.reflect.Proxy代理. <br /> 2) 若目标对象没有实现接口,则Spring使用cglib库生成目标对象的子类.</li> 
           <li>Spring只支持方法连接点,不提供属性连接.</li> 
           <li>标记为final的方法不能被代理,因为无法进行覆盖.</li> 
           <li>程序应优先对针对接口代理,这样便于程序解耦/维护.</li> 
           <h2>Spring AOP</h2> 
           <p>AOP联盟为通知Advice定义了org.aopalliance.aop.Advice接口, Spring在Advice的基础上,根据通知在目标方法的连接点位置,扩充为以下五类:</p> 
           <table> 
            <tbody>
             <tr>
               通知 接口 描述 
             </tr> 
             <tr> 
              <td>前置通知</td> 
              <td>MethodBeforeAdvice</td> 
              <td>在目标方法执行<strong>前</strong>实施增强</td> 
             </tr> 
             <tr> 
              <td>后置通知</td> 
              <td>AfterReturningAdvice</td> 
              <td>…执行<strong>后</strong>实施增强</td> 
             </tr> 
             <tr> 
              <td>环绕通知</td> 
              <td>MethodInterceptor</td> 
              <td>..执行<strong>前后</strong>实施增强</td> 
             </tr> 
             <tr> 
              <td>异常抛出通知</td> 
              <td>ThrowsAdvice</td> 
              <td>…抛出<strong>异常</strong>后实施增强</td> 
             </tr> 
             <tr> 
              <td>引介通知</td> 
              <td>IntroductionInterceptor</td> 
              <td>在目标类中<strong>添加新的方法和属性</strong>(少用)</td> 
             </tr> 
            </tbody>
           </table> 
           <li>添加Spring的AOP依赖 <br /> 使用Spring的AOP和AspectJ需要在pom.xml中添加如下依赖:</li> 
           <pre class="sycode">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;</pre> 
           <li>定义Target</li> 
           <pre class="sycode">/**
 * @author jifang
 * @since 16/3/3 下午2:50.
 */
public interface OrderService {

    void save();

    Integer delete(Integer param);
}</pre> 
           <pre class="sycode">public class OrderServiceImpl implements OrderService {

    @Override
    public void save() {
        System.out.println(&quot;添加...&quot;);
    }

    @Override
    public Integer delete(Integer param) {
        System.out.println(&quot;删除...&quot;);
        return param;
    }
}</pre> 
           <li>定义Advice</li> 
           <pre class="sycode">/**
 * 实现MethodInterceptor接口定义环绕通知
 *
 * @author jifang
 * @since 16/3/6 下午2:54.
 */
public class ConcreteInterceptor implements MethodInterceptor {

    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println(&quot;前置通知 -&gt; &quot;);

        Object result = invocation.proceed();

        System.out.println(&quot;&lt;- 后置通知&quot;);

        return result;
    }
}</pre> 
           <h3>Spring手动代理</h3> 
           <li>配置代理 <br /> Spring最原始的AOP支持, 手动指定目标对象与通知(没有使用AOP名称空间).</li> 
           <pre class="sycode">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
 xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!-- target --&gt;
    &lt;bean id=&quot;service&quot; class=&quot;com.fq.service.impl.OrderServiceImpl&quot;/&gt;
    &lt;!-- advice --&gt;
    &lt;bean id=&quot;advice&quot; class=&quot;com.fq.advice.ConcreteInterceptor&quot;/&gt;

    &lt;bean id=&quot;serviceProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
        &lt;property name=&quot;target&quot; ref=&quot;service&quot;/&gt;
        &lt;property name=&quot;interceptorNames&quot; value=&quot;advice&quot;/&gt;
        &lt;property name=&quot;proxyTargetClass&quot; value=&quot;false&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre> 
           <li>Client</li> 
           <pre class="sycode">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &quot;classpath:spring/applicationContext.xml&quot;)
public class AOPClient {

    @Autowired
    // 必须指定使用代理对象名称, 否则不予代理
    @Qualifier(&quot;serviceProxy&quot;)
    private OrderService service;

    @Test
    public void client() {
        service.save();
        service.delete(88);
    }
}</pre> 
           <p>这种方式的缺陷在于每个Target都必须手动指定ProxyFactoryBean对其代理(不能批量指定),而且这种方式会在Spring容器中存在两份Target对象(代理前/代理后),浪费资源,且容易出错(比如没有指定@Qualifier).</p> 
           <h3>Spring自动代理 - 引入AspectJ</h3> 
           <p>通过AspectJ引入Pointcut切点定义</p> 
           <li>Target/Advice同前</li> 
           <li>定义切面表达式 <br /> 通过execution函数定义切点表达式(定义切点的方法切入) <br /> execution(&lt;访问修饰符&gt; &lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;) <br /> 如: <br /> 1) execution(public * *(..)) # 匹配所有 public方法. <br /> 2) execution(* com.fq.dao.*(..)) # 匹配指定包下所有类方法(不包含子包) <br /> 3) execution(* com.fq.dao..*(..)) # 匹配指定包下所有类方法(包含子包) <br /> 4) execution(* com.fq.service.impl.OrderServiceImple.*(..)) # 匹配指定类所有方法 <br /> 5) execution(* com.fq.service.OrderService+.*(..)) # 匹配实现特定接口所有类方法 <br /> 6) execution(* save*(..)) # 匹配所有save开头的方法 </li> 
           <pre class="sycode">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
 xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
 xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans.xsd
 http://www.springframework.org/schema/aop
 http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

    &lt;!-- target --&gt;
    &lt;bean id=&quot;service&quot; class=&quot;com.fq.service.impl.OrderServiceImpl&quot;/&gt;
    &lt;!-- advice --&gt;
    &lt;bean id=&quot;advice&quot; class=&quot;com.fq.advice.ConcreteInterceptor&quot;/&gt;

    &lt;!-- 配置切面 : proxy-target-class确定是否使用CGLIB --&gt;
    &lt;aop:config proxy-target-class=&quot;true&quot;&gt;
        &lt;!--
 aop:pointcut : 切点定义
 aop:advisor: 定义Spring传统AOP的切面,只支持一个pointcut/一个advice
 aop:aspect : 定义AspectJ切面的,可以包含多个pointcut/多个advice
 --&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.fq.service.impl.OrderServiceImpl.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;advice&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    &lt;/aop:config&gt;

&lt;/beans&gt;</pre> 
           <li>Client同前</li> 
           <h2>AspectJ AOP</h2> 
           <p>AspectJ是一个基于Java的AOP框架,提供了强大的AOP功能,其他很多AOP框架都借鉴或采纳了AspectJ的一些思想,Spring2.0以后增加了对AspectJ切点表达式支持(如上),并在Spring3.0之后与AspectJ进行了很好的集成. <br /> 在Java领域,AspectJ中的很多语法结构基本上已成为AOP领域的标准, 他定义了如下几类通知类型:</p> 
           <table> 
            <tbody>
             <tr>
               通知 接口 描述 
             </tr> 
             <tr> 
              <td>前置通知</td> 
              <td>@Before</td> 
              <td>相当于BeforeAdvice</td> 
             </tr> 
             <tr> 
              <td>后置通知</td> 
              <td>@AfterReturning</td> 
              <td>相当于AfterReturningAdvice</td> 
             </tr> 
             <tr> 
              <td>环绕通知</td> 
              <td>@Around</td> 
              <td>相当于MethodInterceptor</td> 
             </tr> 
             <tr> 
              <td>抛出通知</td> 
              <td>@AfterThrowing</td> 
              <td>相当于ThrowAdvice</td> 
             </tr> 
             <tr> 
              <td>引介通知</td> 
              <td>@DeclareParents</td> 
              <td>相当于IntroductionInterceptor</td> 
             </tr> 
             <tr> 
              <td>最终final通知</td> 
              <td>@After</td> 
              <td>不管是否异常,该通知都会执行</td> 
             </tr> 
            </tbody>
           </table> 
           <p>新版本Spring,建议使用AspectJ方式开发以简化AOP配置.</p> 
           <h2>AspectJ-XML-AOP</h2> 
           <p>使用AspectJ编写Advice无需实现任何接口,而且可以将多个通知写入一个切面类.</p> 
           <h3>前置通知</h3> 
           <li>定义通知</li> 
           <pre class="sycode">/**
 * @author jifang
 * @since 16/3/3 下午5:38.
 */
public class Aspect {

    /**
 * 无返回值
 */
    public void before1() {
        System.out.println(&quot;前置增强before1&quot;);
    }

    /**
 * 还可以传入连接点参数 JoinPoint
 *
 * @param point
 */
    public void before2(JoinPoint point) {
        System.out.printf(&quot;前置增强before2 %s%n&quot;, point.getKind());
    }
}</pre> 
           <li>装配</li> 
           <pre class="sycode">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
 xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
 xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
 xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans.xsd
 http://www.springframework.org/schema/aop
 http://www.springframework.org/schema/aop/spring-aop.xsd
 http://www.springframework.org/schema/context
 http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;com.fq.service&quot;/&gt;

    &lt;!-- 配置切面通知 --&gt;
    &lt;bean id=&quot;advice&quot; class=&quot;com.fq.advice.Aspect&quot;/&gt;

    &lt;!-- AOP切面配置 --&gt;
    &lt;aop:config&gt;
        &lt;aop:aspect ref=&quot;advice&quot;&gt;
            &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.fq.service.impl.OrderServiceImpl.*(..))&quot;/&gt;
            &lt;aop:before method=&quot;before1&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:before method=&quot;before2&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;

&lt;/beans&gt;</pre> 
           <li>前置通知小结 <br /> </li> 
           <li>前置通知会保证在目标方法执行前执行;</li> 
           <li>前置通知默认不能阻止目标方法执行(但如果通知抛出异常,则目标方法无法执行);</li> 
           <li>可以通过JoinPoint参数获得当前拦截对象和方法等信息.</li> 
           <h3>后置通知</h3> 
           <li>定义通知</li> 
           <pre class="sycode">public void afterReturning(JoinPoint point, Object result) {
    System.out.printf(&quot;后置增强, 结果为 %s%n&quot;, result);
}</pre> 
           <li>装配</li> 
           <pre class="sycode">&lt;aop:after-returning method=&quot;afterReturning&quot; returning=&quot;result&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</pre> 
           <p>后置通知可以获得方法返回值,但在配置文件定义返回值参数名必须与后置通知方法参数名一致(如result).</p> 
           <h3>环绕通知</h3> 
           <li>定义通知</li> 
           <pre class="sycode">public Object around(ProceedingJoinPoint point) throws Throwable {
    System.out.printf(&quot;环绕前置增强 method: %s, args: %s%n&quot;, point.toShortString(), Arrays.toString(point.getArgs()));

    Object result = point.proceed(point.getArgs());

    System.out.printf(&quot;环绕后置增强 result: %s%n&quot;, result);

    return result;
}</pre> 
           <li>装配</li> 
           <pre class="sycode">&lt;aop:around method=&quot;around&quot; arg-names=&quot;point&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</pre> 
           <p>环绕通知可以实现任何通知的效果, 甚至可以阻止目标方法的执行.</p> 
           <h3>抛出通知</h3> 
           <li>定义通知</li> 
           <pre class="sycode">private static final Logger LOGGER = LoggerFactory.getLogger(Aspect.class);

public void afterThrowing(JoinPoint point, Throwable ex) {
    String message = new StringBuilder(&quot;method &quot;).append(point.getSignature().getName()).append(&quot; error&quot;).toString();
    System.out.println(message);

    LOGGER.error(&quot;{},&quot;, message, ex);
}</pre> 
           <li>装配</li> 
           <pre class="sycode">&lt;aop:after-throwing method=&quot;afterThrowing&quot; throwing=&quot;ex&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</pre> 
           <p>throwing属性指定异常对象名, 该名称应和方法定义参数名一致.</p> 
           <h3>最终通知</h3> 
           <li>定义通知</li> 
           <pre class="sycode">public void after(JoinPoint point) {
    System.out.println(&quot;最终通知, 释放资源&quot;);
}</pre> 
           <li>装配</li> 
           <pre class="sycode">&lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</pre> 
           <p>无论目标方法是否出现异常,该通知都会执行(类似finally代码块, 应用场景为释放资源).</p> 
           <h2>AspectJ-Annotation-AOP</h2> 
           <p>@AspectJ是AspectJ 1.5新增功能,可以通过JDK注解技术,直接在Bean类中定义切面. <br /> AspectJ预定义的注解有:@Before/@AfterReturning/@Around/@AfterThrowing/@DeclareParents/@After.描述同前. <br /> 使用AspectJ注解AOP需要在applicationContext.xml文件中开启注解自动代理功能:</p> 
           <pre class="sycode">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
 xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
 xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
 xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans.xsd
 http://www.springframework.org/schema/aop
 http://www.springframework.org/schema/aop/spring-aop.xsd
 http://www.springframework.org/schema/context
 http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!-- 批量扫描@Component --&gt;
    &lt;context:component-scan base-package=&quot;com.fq&quot;/&gt;
    &lt;!-- 启用注解自动代理@Aspect--&gt;
    &lt;aop:aspectj-autoproxy/&gt;
&lt;/beans&gt;</pre> 
           <li>OrderService/Client同前</li> 
           <h3>@Before</h3> 
           <li>Aspect</li> 
           <pre class="sycode">/**
 * @Aspect: 指定是一个切面
 * @Component: 指定可以被Spring容器扫描到
 */
@Aspect
@Component
public class CustomAspect {

    @Before(&quot;execution(* com.fq.service.impl.OrderServiceImpl.*(..))&quot;)
    public void before(JoinPoint point) {
        System.out.printf(&quot;前置增强before2 %s%n&quot;, point.getKind());
    }
}</pre> 
           <h3>@AfterReturning</h3> 
           <pre class="sycode">@AfterReturning(value = &quot;execution(* com.fq.service.impl.OrderServiceImpl.d*(..))&quot;, returning = &quot;result&quot;)
public void afterReturning(JoinPoint point, Object result) {
    System.out.printf(&quot;后置增强, 结果为 %s%n&quot;, result);
}</pre> 
           <h3>@Around</h3> 
           <pre class="sycode">@Around(&quot;execution(* com.fq.service.impl.OrderServiceImpl.*(..))&quot;)
public Object around(ProceedingJoinPoint point) throws Throwable {
    long start = System.currentTimeMillis();
    Object result = point.proceed(point.getArgs());
    long time = System.currentTimeMillis() - start;

    System.out.printf(&quot;method %s invoke consuming %d ms%n&quot;, point.toLongString(), time);

    return result;
}</pre> 
           <p>如果不调用ProceedingJoinPoint的proceed方法,那么目标方法就不执行了.</p> 
           <h3>@AfterThrowing</h3> 
           <pre class="sycode">@AfterThrowing(value = &quot;execution(* com.fq.service.impl.OrderServiceImpl.*(..))&quot;, throwing = &quot;ex&quot;)
public void afterThrowing(JoinPoint point, Throwable ex) {
    String message = new StringBuilder(&quot;method &quot;).append(point.getSignature().getName()).append(&quot; error&quot;).toString();
    System.out.println(message);

    LOGGER.error(&quot;{},&quot;, message, ex);
}</pre> 
           <h3>@After</h3> 
           <pre class="sycode">@After(&quot;execution(* com.fq.service.impl.OrderServiceImpl.*(..))&quot;)
public void after(JoinPoint point) {
    System.out.println(&quot;最终通知, 释放资源&quot;);
}</pre> 
           <h3>@Pointcut定义切点</h3> 
           <p>对于重复的切点,可以使用@Pointcut进行定义, 然后在通知注解内引用.</p> 
           <li>定义切点方法 <br /> 无参/无返回值/方法名为切点名:</li> 
           <pre class="sycode">/**
 * @author jifang
 * @since 16/3/4 上午11:47.
 */
public class OrderServicePointcut {

    @Pointcut(&quot;execution(* com.fq.service.impl.OrderServiceImpl.*(..))&quot;)
    public void pointcut() {
    }
}</pre> 
           <li>引用切点 <br /> 在Advice上像调用方法一样引用切点:</li> 
           <pre class="sycode">@After(&quot;OrderServicePointcut.pointcut()&quot;)
public void after(JoinPoint point) {
    System.out.println(&quot;最终通知, 释放资源&quot;);
}</pre> 
           <p>1) 如果切点与切面在同一个类内, 可省去类名前缀; <br /> 2) 当需要通知多个切点时,可以使用||/&amp;&amp;进行连接.</p> 
           <h3>小结</h3> 
           <table> 
            <tbody>
             <tr>
               通知 描述 
             </tr> 
             <tr> 
              <td>前置通知</td> 
              <td>权限控制(少用)</td> 
             </tr> 
             <tr> 
              <td>后置通知</td> 
              <td>少用</td> 
             </tr> 
             <tr> 
              <td>环绕通知</td> 
              <td>权限控制/性能监控/缓存实现/事务管理</td> 
             </tr> 
             <tr> 
              <td>异常通知</td> 
              <td>发生异常后,记录错误日志</td> 
             </tr> 
             <tr> 
              <td>最终通知</td> 
              <td>释放资源</td> 
             </tr> 
            </tbody>
           </table> 
          </div> 
         </div> 
        </div> 
        <div class="contentDown2"> 
         <div id="gg" style="float:left;width:300px;margin:5px;"> 
          <script type="text/javascript">
var cpro_id="u2064564";
(window["cproStyleApi"] = window["cproStyleApi"] || {})[cpro_id]={at:"3",rsi0:"300",rsi1:"250",pat:"17",tn:"baiduCustNativeAD",rss1:"#FFFFFF",conBW:"1",adp:"1",ptt:"0",titFF:"%E5%BE%AE%E8%BD%AF%E9%9B%85%E9%BB%91",titFS:"14",rss2:"#000000",titSU:"0"}
</script> 
          <script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script> 
         </div> 
        </div> 
        <div style="text-align:center;margin-top:5px"> 
         <script type="text/javascript">
var cpro_id="u2057855";
(window["cproStyleApi"] = window["cproStyleApi"] || {})[cpro_id]={at:"3",rsi0:"739",rsi1:"250",pat:"6",tn:"baiduCustNativeAD",rss1:"#FBFBFB",conBW:"1",adp:"1",ptt:"0",titFF:"%E5%BE%AE%E8%BD%AF%E9%9B%85%E9%BB%91",titFS:"13",rss2:"#000000",titSU:"0",ptbg:"90",piw:"0",pih:"0",ptp:"0"}
</script> 
         <script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script> 
        </div> 
        <div id="fenxiang">
         <span style="color:#aaaaaa" id="originUrl"></span>
        </div> 
       </div> 
      </div> 
      <div class="wgt-relate-search mt-5 mb-5"> 
       <h2>相关搜索：</h2> 
       <a href="/s/spring%20aop.html" target="_blank">spring aop</a> 
       <a href="/s/spring%20aop%20%e8%af%a6%e8%a7%a3.html" target="_blank">spring aop 详解</a> 
       <a href="/s/spring%20aop%20%e4%be%8b%e5%ad%90.html" target="_blank">spring aop 例子</a> 
       <a href="/s/spring%20aop%e9%85%8d%e7%bd%ae.html" target="_blank">spring aop配置</a> 
       <a href="/s/spring%20aop%e4%be%8b%e5%ad%90.html" target="_blank">spring aop例子</a> 
      </div> 
      <div class="wgt-related mt-5 " id="wgt-related"> 
       <h2>相关文章</h2> 
       <div class="leftlist"> 
        <ul> 
         <li><span class="grid-r tm">2016-04-07 10:09</span> <a href="/detail/6482759.html"> Spring AOP的最佳实践 </a> </li> 
         <li><span class="grid-r tm">2016-07-28 16:19</span> <a href="/detail/6613890.html"> Spring AOP和AspectJ学习实践 </a> </li> 
         <li><span class="grid-r tm">2015-08-04 23:55</span> <a href="/detail/6337125.html"> Spring AOP的实现 </a> </li> 
         <li><span class="grid-r tm">2015-06-20 11:31</span> <a href="/detail/6300937.html"> Spring AOP </a> </li> 
         <li><span class="grid-r tm">2015-03-16 21:42</span> <a href="/detail/6225566.html"> Spring --AOP </a> </li> 
        </ul> 
       </div> 
       <div class="mt-10"> 
        <a href="/st/6464416.html"> 更多相关文章&gt;&gt; </a> 
       </div> 
      </div> 
      <div class="wgt-related mt-5 " id="wgt-related"> 
       <h2>最新文章</h2> 
       <div class="leftlist"> 
        <ul> 
         <li><span class="grid-r tm">2017-03-28 17:04</span> <a href="/detail/6737150.html"> Spring下扫描特定包下特定注解的类并动态注册bean </a> </li> 
         <li><span class="grid-r tm">2017-03-28 16:30</span> <a href="/detail/6737146.html"> spring boot admin slack报警 </a> </li> 
         <li><span class="grid-r tm">2017-03-28 15:29</span> <a href="/detail/6737059.html"> 文件上传之SpringMVC </a> </li> 
         <li><span class="grid-r tm">2017-03-28 15:28</span> <a href="/detail/6737053.html"> Springmvc+uploadify实现文件上传 </a> </li> 
         <li><span class="grid-r tm">2017-03-28 13:43</span> <a href="/detail/6736971.html"> 在spring cloud中使用springboot admin </a> </li> 
        </ul> 
       </div> 
       <div class="mt-10"> 
        <a href="/type/7.html"> 更多最新文章&gt;&gt; </a> 
       </div> 
      </div> 
     </article> 
     <aside class="grid qb-side" id="qb-side"> 
      <div class="cms-slide"> 
       <div class="remen"> 
        <p class="h2">热门搜索</p> 
        <ul> 
         <li><a href="/s/spring%20aop%e6%98%af%e4%bb%80%e4%b9%88.html" target="_blank">spring aop是什么</a></li> 
         <li><a href="/s/spring%e7%9a%84aop.html" target="_blank">spring的aop</a></li> 
         <li><a href="/s/spring%20aop%e6%a6%82%e5%bf%b5.html" target="_blank">spring aop概念</a></li> 
         <li><a href="/s/spring%20aop%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86.html" target="_blank">spring aop实现原理</a></li> 
         <li><a href="/s/spring%20aop%e9%85%8d%e7%bd%ae%e4%ba%8b%e5%8a%a1.html" target="_blank">spring aop配置事务</a></li> 
         <li><a href="/s/spring%20aop%e6%97%a5%e5%bf%97.html" target="_blank">spring aop日志</a></li> 
         <li><a href="/s/spring%20aop%e6%97%a5%e5%bf%97%e7%ae%a1%e7%90%86.html" target="_blank">spring aop日志管理</a></li> 
         <li><a href="/s/spring%20aop%20%e8%bf%94%e5%9b%9e%e5%80%bc.html" target="_blank">spring aop 返回值</a></li> 
         <li><a href="/s/spring%e4%b8%adioc%e5%92%8caop.html" target="_blank">spring中ioc和aop</a></li> 
         <li><a href="/s/c%e8%af%ad%e8%a8%80%e5%ae%9e%e8%b7%b5.html" target="_blank">c语言实践</a></li> 
         <li><a href="/s/asp.net%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e5%ae%9e%e8%b7%b5.html" target="_blank">asp.net从入门到实践</a></li> 
         <li><a href="/s/spring.html" target="_blank">spring</a></li> 
         <li><a href="/s/in%20spring.html" target="_blank">in spring</a></li> 
         <li><a href="/s/ejb%20spring.html" target="_blank">ejb spring</a></li> 
         <li><a href="/s/spring%20ejb.html" target="_blank">spring ejb</a></li> 
        </ul> 
       </div> 
      </div> 
      <div class="cms-slide"> 
       <script type="text/javascript">
var cpro_id="u2062662";
(window["cproStyleApi"] = window["cproStyleApi"] || {})[cpro_id]={at:"3",rsi0:"300",rsi1:"280",pat:"17",tn:"baiduCustNativeAD",rss1:"#FFFFFF",conBW:"1",adp:"1",ptt:"1",ptc:"%E7%8C%9C%E4%BD%A0%E6%84%9F%E5%85%B4%E8%B6%A3",ptFS:"14",ptFC:"#000000",ptBC:"#F2F2F2",titFF:"%E5%BE%AE%E8%BD%AF%E9%9B%85%E9%BB%91",titFS:"12",rss2:"#000000",titSU:"0"}
</script> 
       <script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script> 
      </div> 
      <div class="cms-slide" id="tuijian"></div> 
      <div class="fixed"> 
       <div class="cms-slide"> 
        <script type="text/javascript">
    var cpro_id = "u2062674";
</script> 
        <script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script> 
       </div> 
       <div class="cms-slide"> 
        <script type="text/javascript">
var cpro_id="u1983378";
(window["cproStyleApi"] = window["cproStyleApi"] || {})[cpro_id]={at:"3",rsi0:"300",rsi1:"250",pat:"6",tn:"baiduCustNativeAD",rss1:"#FFFFFF",conBW:"1",adp:"1",ptt:"0",titFF:"%E5%BE%AE%E8%BD%AF%E9%9B%85%E9%BB%91",titFS:"13",rss2:"#333333",titSU:"0",ptbg:"90",piw:"0",pih:"0",ptp:"0"}
</script> 
        <script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script> 
       </div> 
      </div> 
     </aside> 
    </section> 
   </div> 
   <footer id="footer">
    <p>京ICP备14022385号-2</p>
    <p>&copy;2014 <a href="/">ITnose软件编程教程</a>&nbsp;|&nbsp;联系我们：Email：twobrushes@126.com &nbsp;&nbsp;QQ:35155868</p>
    <p style="display:none"><script language="javascript" type="text/javascript" src="http://js.users.51.la/16757612.js"></script><script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1258921346'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1258921346%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></p>
   </footer> 
  </div> 
  <script>
$(document).ready(function(e) {			
	t = $('.fixed').offset().top;
	mh = $('article').height();
	mt = $('article').offset().top;
	fh = $('.fixed').height();
	$(window).scroll(function(e){
		s = $(document).scrollTop();	
		if(s > t-1){
			$('.fixed').css('position','fixed');
			if(s + fh > mh+mt){
				$('.fixed').css('top',mh+mt-s-fh+'px');	
			}else{
				$('.fixed').css('top',mh-s+'px');
				$('.fixed').offset({top:s});
			}				
		}else{
			$('.fixed').css('position','');
		}
	})
});
var tuijiandoc='<div class="cms-inner"><p class="h2 ml-5">推荐文章</p><ul class="ml-5" ><li ><a href="/detail/6482759.html"> Spring AOP的最佳实践</a></li><li ><a href="/detail/6613890.html"> Spring AOP和AspectJ学习实践</a></li><li ><a href="/detail/6337125.html"> Spring AOP的实现</a></li><li ><a href="/detail/6300937.html"> Spring AOP</a></li><li ><a href="/detail/6225566.html"> Spring --AOP</a></li><li ><a href="/detail/6141564.html"> Spring??AOP</a></li><li ><a href="/detail/6131294.html"> Spring之AOP</a></li><li ><a href="/detail/474905.html"> Spring AOP</a></li></ul></div>';
document.getElementById("tuijian").innerHTML=tuijiandoc;
//document.getElementById("originUrl").innerHTML="From : http://blog.csdn.net/zjf280441589/article/details/50816802";
var contentDown=$(tuijiandoc);
contentDown.find("p").html('<span class="h2">相关文章</span><span style="font-size:13px;float:right;padding-right:25px"><a href="/st/6464416.html">&lt;&lt;更多&gt;&gt;</a></span>').removeAttr("class").attr("style","border-bottom: 1px dashed #aaa;height:26px;margin-right:10px;margin-bottom:2px");
contentDown.find("ul").removeAttr("class");
contentDown.attr("class","contentDown");
$('.contentDown2').append(contentDown);
</script>  
 </body>
</html>